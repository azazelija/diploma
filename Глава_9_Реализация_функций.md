# 9. РЕАЛИЗАЦИЯ ОСНОВНЫХ ФУНКЦИЙ УПРАВЛЕНИЯ ЗАДАЧАМИ

В данном разделе представлена реализация ключевых функций управления задачами, обеспечивающих полный жизненный цикл работы с задачами в системе. Функционал разработан с использованием архитектуры REST API и включает операции создания, чтения, обновления и удаления задач.

Серверная часть приложения организована на основе API-маршрутов Next.js, расположенных в директории app/api/tasks. Маршруты обеспечивают взаимодействие с базой данных PostgreSQL через слой абстракции, реализованный в модуле lib/db.ts. Все операции выполняются с использованием параметризованных SQL-запросов, что защищает систему от SQL-инъекций.

## Получение списка задач

Функция получения задач реализована через GET-запрос к эндпоинту /api/tasks. Данная функция поддерживает фильтрацию по статусу и приоритету задач через параметры запроса. Реализован динамический SQL-запрос с объединением таблиц для получения полной информации о задаче, включая данные о статусе, создателе и исполнителе:

```typescript
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const status = searchParams.get('status');
    const priority = searchParams.get('priority');
    
    let sql = `
      SELECT 
        t.id, t.title, t.description, t.priority, t.due_date, 
        t.completed_at, t.created_at, t.updated_at,
        s.id as status_id, s.name as status_name, s.color as status_color,
        u_created.username as created_by_name,
        u_assigned.username as assigned_to_name
      FROM tasks t
      LEFT JOIN task_statuses s ON t.status_id = s.id
      LEFT JOIN users u_created ON t.created_by = u_created.id
      LEFT JOIN users u_assigned ON t.assigned_to = u_assigned.id
      WHERE 1=1
    `;
    
    const params: any[] = [];
    let paramIndex = 1;
    
    if (status) {
      sql += ` AND s.name = $${paramIndex}`;
      params.push(status);
      paramIndex++;
    }
    
    if (priority) {
      sql += ` AND t.priority = $${paramIndex}`;
      params.push(priority);
      paramIndex++;
    }
    
    sql += ' ORDER BY t.created_at DESC';
    const result = await query(sql, params);
    
    return NextResponse.json({
      success: true,
      data: result.rows,
      count: result.rowCount,
    });
  } catch (error) {
    return NextResponse.json(
      { success: false, error: 'Failed to fetch tasks' },
      { status: 500 }
    );
  }
}
```

Запрос выполняет левое соединение (LEFT JOIN) с таблицами статусов и пользователей, что позволяет получить полную информацию даже для задач без назначенного исполнителя. Применена сортировка по дате создания в убывающем порядке для отображения новых задач в начале списка.

## Создание новой задачи

Операция создания задачи реализована через POST-запрос. Выполняется валидация обязательных полей на серверной стороне. Для полей, не указанных клиентом, устанавливаются значения по умолчанию:

```typescript
export async function POST(request: NextRequest) {
  try {
    const body: CreateTaskDTO = await request.json();
    
    if (!body.title || body.title.trim() === '') {
      return NextResponse.json(
        { success: false, error: 'Title is required' },
        { status: 400 }
      );
    }
    
    const createdBy = body.created_by || 1;
    const statusId = body.status_id || 1;
    const priority = body.priority || 'medium';
    
    const sql = `
      INSERT INTO tasks (title, description, status_id, priority, 
                         created_by, assigned_to, due_date)
      VALUES ($1, $2, $3, $4, $5, $6, $7)
      RETURNING *
    `;
    
    const params = [
      body.title.trim(),
      body.description || null,
      statusId,
      priority,
      createdBy,
      body.assigned_to || null,
      body.due_date || null,
    ];
    
    const result = await query(sql, params);
    
    return NextResponse.json(
      {
        success: true,
        data: result.rows[0],
        message: 'Task created successfully',
      },
      { status: 201 }
    );
  } catch (error) {
    return NextResponse.json(
      { success: false, error: 'Failed to create task' },
      { status: 500 }
    );
  }
}
```

Использована конструкция RETURNING *, позволяющая вернуть созданную запись с автоматически сгенерированным идентификатором и временными метками. Это обеспечивает немедленное получение полных данных о созданной задаче без дополнительного запроса.

## Обновление задачи

Обновление задачи реализовано через PUT-запрос к эндпоинту /api/tasks/[id]. Применён динамический подход к формированию SQL-запроса, позволяющий обновлять только переданные поля:

```typescript
export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const { id } = params;
    const body: UpdateTaskDTO & { updated_by?: number } = await request.json();
    
    const checkResult = await query('SELECT id FROM tasks WHERE id = $1', [id]);
    if (checkResult.rowCount === 0) {
      return NextResponse.json(
        { success: false, error: 'Task not found' },
        { status: 404 }
      );
    }
    
    const updates: string[] = [];
    const sqlParams: any[] = [];
    let paramIndex = 1;
    
    if (body.title !== undefined) {
      updates.push(`title = $${paramIndex}`);
      sqlParams.push(body.title.trim());
      paramIndex++;
    }
    
    if (body.status_id !== undefined) {
      updates.push(`status_id = $${paramIndex}`);
      sqlParams.push(body.status_id);
      paramIndex++;
    }
    
    if (body.priority !== undefined) {
      updates.push(`priority = $${paramIndex}`);
      sqlParams.push(body.priority);
      paramIndex++;
    }
    
    if (updates.length === 0) {
      return NextResponse.json(
        { success: false, error: 'No fields to update' },
        { status: 400 }
      );
    }
    
    sqlParams.push(id);
    
    const sql = `
      UPDATE tasks 
      SET ${updates.join(', ')}, updated_at = CURRENT_TIMESTAMP
      WHERE id = $${paramIndex}
      RETURNING *
    `;
    
    const result = await query(sql, sqlParams);
    
    return NextResponse.json({
      success: true,
      data: result.rows[0],
      message: 'Task updated successfully',
    });
  } catch (error) {
    return NextResponse.json(
      { success: false, error: 'Failed to update task' },
      { status: 500 }
    );
  }
}
```

Перед обновлением выполняется проверка существования задачи. Динамическое формирование SET-части запроса позволяет обновлять любое количество полей без необходимости перезаписывать все данные. Автоматически обновляется поле updated_at для отслеживания времени последнего изменения.

## Удаление задачи

Удаление задачи выполняется через DELETE-запрос с указанием идентификатора в URL:

```typescript
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const { id } = params;
    
    const result = await query(
      'DELETE FROM tasks WHERE id = $1 RETURNING id', 
      [id]
    );
    
    if (result.rowCount === 0) {
      return NextResponse.json(
        { success: false, error: 'Task not found' },
        { status: 404 }
      );
    }
    
    return NextResponse.json({
      success: true,
      message: 'Task deleted successfully',
    });
  } catch (error) {
    return NextResponse.json(
      { success: false, error: 'Failed to delete task' },
      { status: 500 }
    );
  }
}
```

## Клиентская интеграция

На клиентской стороне реализованы функции-обработчики для взаимодействия с API. Функция создания задачи включает передачу идентификатора текущего пользователя:

```typescript
const handleCreateTask = async (formData: TaskFormData) => {
  if (!user) return;

  try {
    const response = await fetch('/api/tasks', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ...formData,
        created_by: user.id,
      }),
    });

    if (!response.ok) {
      throw new Error('Failed to create task');
    }

    await loadData();
    setShowModal(false);
    setError(null);
  } catch (err) {
    setError('Ошибка создания задачи');
  }
}
```

Для обновления задачи применяется аналогичный подход с методом PUT:

```typescript
const handleUpdateTask = async (formData: TaskFormData) => {
  if (!editingTask || !user) return;

  try {
    const response = await fetch(`/api/tasks/${editingTask.id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ...formData,
        updated_by: user.id,
      }),
    });

    if (!response.ok) {
      throw new Error('Failed to update task');
    }

    await loadData();
    setEditingTask(null);
    setShowEditModal(false);
  } catch (err) {
    setError('Ошибка обновления задачи');
  }
}
```

Удаление задачи выполняется с предварительным запросом подтверждения у пользователя:

```typescript
const handleDeleteTask = async (taskId: number) => {
  if (!confirm('Вы уверены, что хотите удалить эту задачу?')) return;

  try {
    const response = await fetch(`/api/tasks/${taskId}`, {
      method: 'DELETE',
    });

    if (!response.ok) {
      throw new Error('Failed to delete task');
    }

    await loadData();
  } catch (err) {
    setError('Ошибка удаления задачи');
  }
}
```

Реализована функция быстрого изменения статуса задачи, позволяющая перемещать задачи между колонками канбан-доски:

```typescript
const handleStatusChange = async (taskId: number, statusId: number) => {
  if (!user) return;
  
  try {
    const response = await fetch(`/api/tasks/${taskId}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ 
        status_id: statusId,
        updated_by: user.id,
      }),
    });

    if (!response.ok) {
      throw new Error('Failed to update status');
    }

    await loadData();
  } catch (err) {
    setError('Ошибка изменения статуса');
  }
}
```

## Типизация данных

Для обеспечения типобезопасности определены TypeScript-интерфейсы в файле types/task.ts:

```typescript
export type TaskPriority = 'low' | 'medium' | 'high' | 'urgent';

export interface Task {
  id: number;
  title: string;
  description: string | null;
  status_id: number;
  priority: TaskPriority;
  assigned_to: number | null;
  created_by: number;
  due_date: Date | null;
}

export interface CreateTaskDTO {
  title: string;
  description?: string;
  status_id?: number;
  priority?: TaskPriority;
  created_by?: number;
  assigned_to?: number;
  due_date?: string;
}
```

Все операции с задачами сопровождаются обработкой ошибок. На серверной стороне ошибки логируются в консоль для последующей диагностики. Клиентская часть отображает информативные сообщения об ошибках пользователю через механизм состояния. После успешного выполнения операции данные автоматически перезагружаются для синхронизации состояния приложения.

В результате создана надёжная и расширяемая система управления задачами, обеспечивающая все необходимые операции CRUD с применением современных практик веб-разработки.

[Место для вставки рисунка 2]

---

**Предложение по иллюстрации для данного раздела:**

**Рисунок 2 — Структура API-маршрутов в проводнике VS Code**

Способ получения изображения: собственный скриншот проводника файлов в редакторе VS Code (открыть проект в VS Code, в боковой панели Explorer развернуть папку app/api/tasks, чтобы была видна структура с файлами route.ts и подпапкой [id] с route.ts внутри, сделать скриншот боковой панели с развёрнутым деревом директорий).

Желательно, чтобы на скриншоте были видны:
 структура директории app/api с вложенными папками tasks и auth;
 файл route.ts в папке tasks (основные операции GET и POST);
 папка [id] с файлом route.ts внутри (операции GET, PUT, DELETE для конкретной задачи);
 другие API-маршруты для контекста (auth, statuses).

---

Количество символов (с пробелами): 8142
